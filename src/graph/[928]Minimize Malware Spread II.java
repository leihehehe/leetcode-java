package graph;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

//leetcode submit region begin(Prohibit modification and deletion)

/**
 * O(mn^2)的复杂度，假设移除了某个node，然后从其他initial node中进行遍历，看被感染的有多少node
 * m是initial的个数，n是graph的个数
 * 找感染数量最少的
 */
class MinMalwareSpreadIISolution1 {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial); // 确保按照题目要求返回最小的节点
        int minInfected = Integer.MAX_VALUE;
        int res = -1;

        for (int removeIndex : initial) {
            boolean[] visited = new boolean[graph.length];
            int totalInfected = 0; // 感染计数

            for (int node : initial) {
                if (node == removeIndex) continue; // 跳过被删除的节点
                if (!visited[node]) {
                    // 只计算没有访问过的节点
                    totalInfected += dfs(node, removeIndex, graph, visited);
                }
            }

            if (totalInfected < minInfected) {
                minInfected = totalInfected;
                res = removeIndex;
            }
        }
        return res;
    }

    private int dfs(int current, int delete, int[][] graph, boolean[] visited) {
        if (current == delete || visited[current]) return 0; // 如果当前节点是删除节点或已访问，则跳过
        visited[current] = true;
        int infectionCount = 1; // 当前节点被感染

        for (int j = 0; j < graph.length; j++) {
            if (graph[current][j] == 1 && !visited[j] && j != delete) {
                infectionCount += dfs(j, delete, graph, visited);
            }
        }

        return infectionCount;
    }
}

/**
 * O(n^2)
 * 遍历graph对未被感染的node进行分组，遍历是O(n^2), union()方法是O(α(n)),其中α(n)是阿克曼函数的逆，对于所有实际的输入大小，其增长非常缓慢，可以近似认为是常数时间。
 * 然后对每一个initial遍历他们的邻居，记录到map中，看每个未被感染的分组和多少个感染的node进行连接，这是O(m*n)
 * 继续对每个initial遍历他们的邻居，如果邻居只被这一个感染的node所连接的话，比较邻居的个数，然后更新答案
 * 所以时间复杂度是O(2mn+n^2) = O(n^2)，m小于n，可近似n
 */
class MinMalwareSpreadIISolution2 {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        boolean[] isInfected = new boolean[n];
        for (int init : initial) {
            isInfected[init] = true;
        }
        UnionFind uf = new UnionFind(n);
        //得到没有被感染的连通块
        for (int i = 0; i < n; i++) {
            if (isInfected[i]) continue;
            for (int j = 0; j < n; j++) {
                if (i == j) continue;
                if (graph[i][j] == 1 && !isInfected[j] && !uf.isConnected(i, j)) {
                    uf.union(i, j);
                }
            }
        }
        int maxNotInfectedNodes = Integer.MIN_VALUE;
        int minIndexNode = n;
        boolean[] visited = new boolean[n];
        //key: 没有被感染的node(root), value:邻居是被感染node的个数
        Map<Integer, Integer> countMap = new HashMap<>();
        for (int infected : initial) {
            boolean[] counted = new boolean[n];
            for (int neighbor = 0; neighbor < n; neighbor++) {
                if (neighbor == infected || graph[infected][neighbor] == 0 || isInfected[neighbor]) continue;
                int root = uf.find(neighbor);
                if(!counted[root]){
                    counted[root] = true;
                    countMap.put(root, countMap.getOrDefault(root, 0) + 1);
                }
            }
        }
        for (int infected : initial) {
            int notInfectedNodes = 0;
            //避免重复统计同一group的数量
            Arrays.fill(visited, false);
            for (int neighbor = 0; neighbor < n; neighbor++) {
                if (neighbor == infected || graph[infected][neighbor] == 0 || isInfected[neighbor]) continue;
                int root = uf.find(neighbor);
                if (!visited[root]) {
                    visited[root] = true;
                    if (countMap.get(root) == 1)
                        notInfectedNodes += uf.getSize(root);
                }
            }
            if (notInfectedNodes > maxNotInfectedNodes) {
                maxNotInfectedNodes = notInfectedNodes;
                minIndexNode = infected;
            } else if (notInfectedNodes == maxNotInfectedNodes && infected < minIndexNode) {
                minIndexNode = infected;
            }
        }
        return minIndexNode;

    }

    class UnionFind {
        int[] count;
        int[] parent;

        public UnionFind(int n) {
            this.count = new int[n];
            this.parent = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
            Arrays.fill(count, 1);
        }

        public boolean isConnected(int i, int j) {
            return find(i) == find(j);
        }

        public int find(int i) {
            if (parent[i] != i) {
                parent[i] = find(parent[i]);
            }
            return parent[i];
        }

        public void union(int i, int j) {
            int rootI = find(i);
            int rootJ = find(j);
            if (rootI != rootJ) {
                parent[rootI] = rootJ;
                count[rootJ] += count[rootI];
            }

        }

        public int getSize(int i) {
            return count[i];
        }

    }
}
//leetcode submit region end(Prohibit modification and deletion)
