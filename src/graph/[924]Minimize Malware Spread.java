package graph;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

//leetcode submit region begin(Prohibit modification and deletion)
class MinMalwareSpread {
    class UnionFind{
        private int[] parent;
        private int[] count;
        public UnionFind(int n){
            this.parent = new int[n];
            for(int i =0;i<n;i++){
                parent[i] = i;
            }
            this.count = new int[n];
            Arrays.fill(count, 1);
        }
        public void union(int i, int j){
            int rootI = find(i);
            int rootJ = find(j);
            parent[rootI] = rootJ;
            count[rootJ]+= count[rootI];
        }
        public int find(int i){
            if(parent[i]!=i){
                parent[i] = find(parent[i]);
            }
            return parent[i];
        }
        public boolean isConnected(int i, int j){
            return find(i) == find(j);
        }
        public int getGroupSize(int i){
            return count[i];
        }
    }
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        UnionFind uf = new UnionFind(n);
        for(int i=0;i<n;i++){
            for(int j = 0;j<n;j++){
                if(i==j) continue;
                if(graph[i][j]==1 && !uf.isConnected(i, j)){
                    uf.union(i, j);
                }
            }
        }
        Map<Integer, Integer> map = new HashMap<>();
        //找被感染了一个的group，如果有多个感染了一个的node，就检查他的count，如果都没有被感染了一个的group，就找被感染一个以上的的
        for(int node:initial){
            int root = uf.find(node);
            if(map.containsKey(root)){
                map.put(root,map.get(root)+1);
            }else{
                map.put(root,1);
            }
        }
        int minNode = Integer.MAX_VALUE;
        int maxSize = -1;
        int finalMinNode = Integer.MAX_VALUE;
        for (int node : initial) {
            int root = uf.find(node);
            if (map.get(root) == 1) { // 只有一个感染节点的组
                if (uf.getGroupSize(root) > maxSize) {
                    maxSize = uf.getGroupSize(root);
                    minNode = node;
                } else if (uf.getGroupSize(root) == maxSize) {
                    minNode = Math.min(minNode, node); // 选取索引较小的节点
                }
            }
            finalMinNode = Math.min(finalMinNode, node);
        }

        return minNode != Integer.MAX_VALUE ? minNode : finalMinNode;
    }
}
//leetcode submit region end(Prohibit modification and deletion)
